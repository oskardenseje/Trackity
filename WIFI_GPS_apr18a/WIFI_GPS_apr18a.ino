#include "arduino_secrets.h"
 /* 
  Sketch generated by the Arduino IoT Cloud Thing "Ilise"
  https://create.arduino.cc/cloud/things/87bd2369-
c9df-43d0-8a47-6f4b61a0a524 
  Arduino IoT Cloud Variables description
  The following variables are automatically generated and updated when 
changes are made to the Thing
  String carrier_messenger;
  String messenger;
  float altitud;
  float latitude;
  float longitude;
  CloudLocation cloudLocation;
  Variables which are marked as READ/WRITE in the Cloud Thing will also have 
functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this 
sketch.
*/
#include "ArduinoIoTCloud.h"
#include <WiFiNINA.h>
#include <SPI.h>
#include "thingProperties.h"
#include <ArduinoLowPower.h>
#include <TinyGPS.h>//we include TinyGPS
#define WAITING_TIME 1 //waiting time during every message
#define GPS_PIN 2 //(tranistor pin, for energy saving. not used now)
#define GPS_INFO_BUFFER_SIZE 128
bool debug = true; ////////DEBUG/////
const int backlights=4;
const int pulsador=5;
const int audio=3;   
TinyGPS gps;//GPS Object
//GPS data variables
int year;
byte month, day, hour, minute, second, hundredths;
unsigned long chars;
unsigned short sentences, failed_checksum;
char GPS_info_char;
char GPS_info_buffer[GPS_INFO_BUFFER_SIZE];
unsigned int received_char;
bool message_started = false;
String carrier_messenger;
float altitud;
int i = 0;
// GPS coordinate structure, 12 bytes size on 32 bits platforms
struct gpscoord {
  float a_latitude;  // 4 bytes
  float a_longitude; // 4 bytes
  float a_altitude;  // 4 bytes
};
 
//////////////// Waiting function //////////////////
void Wait(int m, bool s) {
  //m minutes to wait
  //s slow led pulses
  if (debug) {
    Serial.print("Waiting: "); Serial.print(m); Serial.println(" min.");
  }
  digitalWrite(LED_BUILTIN, LOW);
  if (s) {
    int seg = m * 30;
    for (int i = 0; i < seg; i++) {
        digitalWrite(backlights, HIGH);
        delay(500);
        digitalWrite(backlights, LOW);
        delay(500);  
    }
  } else {
    int seg = m * 15;
    for (int i = 0; i < seg; i++) {
        digitalWrite(backlights, HIGH);
        delay(500);
        digitalWrite(backlights, LOW);
        delay(500);  
    }
  }
}
//////////////////  Convert GPS function  //////////////////
/* Converts GPS float data to Char data */
String ConvertGPSdata(const void* data, uint8_t len) {
  uint8_t* bytes = (uint8_t*)data;
  String cadena ;
  if (debug) {
    Serial.print("Length: "); Serial.println(len);
  }
  for (uint8_t i = len - 1; i < len; --i) {
    if (bytes[i] < 12) {
      cadena.concat(byte(0)); // Not tested
    }
    cadena.concat(char(bytes[i]));
    if (debug) Serial.print(bytes[i], HEX);
  }
  if (debug) {
    Serial.println("");
 //   Serial.print("String to send: "); Serial.println(cadena);
  }
  return cadena;
}
////////////////////////// Get GPS position function/////////////////////
String GetGPSpositon() {
  int messages_count = 0;
  String pos;
  if (debug) Serial.println("GPS ON");
  digitalWrite(GPS_PIN, HIGH); //Turn GPS on
  Wait(1, false);
  while (messages_count < 5000) {
    while (Serial1.available()) {
      int GPS_info_char = Serial1.read();
      if (GPS_info_char == '$') messages_count ++; // start of message. Counting messages.
      if (debug) {
        if (GPS_info_char == '$') { // start of message
          message_started = true;
          received_char = 0;
        } else if (GPS_info_char == '*') { // end of message
          for (i = 0; i < received_char; i++) {
            Serial.write(GPS_info_buffer[i]); // writes the message to the PC once it has been completely received
          }
      //    Serial.println();
          message_started = false; // ready for the new message
        } else if (message_started == true) { // the message is already started and I got a new character
          if (received_char <= GPS_INFO_BUFFER_SIZE) { // to avoid buffer overflow
            GPS_info_buffer[received_char] = GPS_info_char;
            received_char++;
          } else { // resets everything (overflow happened)
            message_started = false;
            received_char = 0;
          }
        }
      }
      if (gps.encode(GPS_info_char)) {
        gps.f_get_position(&latitude, &longitude);
        altitud = gps.altitude() / 100;
        // Store coordinates into dedicated structure
        gpscoord coords = {altitud, longitude, latitude};
        gps.crack_datetime(&year, &month, &day, &hour, &minute, &second, &hundredths);
        if (debug) {
          Serial.println();
          Serial.println();
          Serial.print("Latitude/Longitude: ");
          Serial.print(latitude, 5);
          Serial.print(", ");
          Serial.println(longitude, 5);
          Serial.println();
      /*  Serial.print("Fecha: "); Serial.print(day, DEC); Serial.print("/");
          Serial.print(month, DEC); Serial.print("/"); Serial.print(year);
          Serial.print(" Hora: "); Serial.print(hour, DEC); Serial.print(":");
          Serial.print(minute, DEC); Serial.print(":"); Serial.print(second, DEC);
          Serial.print("."); Serial.println(hundredths, DEC);
          Serial.print("Altitud (metros): "); Serial.println(gps.f_altitude());
          Serial.print("Rumbo (grados): "); Serial.println(gps.f_course());
          Serial.print("Velocidad(kmph): "); Serial.println(gps.f_speed_kmph()); */
          Serial.print("Satelites: "); Serial.println(gps.satellites());
          Serial.println();
          digitalWrite(backlights, HIGH);
          delay(500);
          digitalWrite(backlights, LOW);
          delay(500);  
        }
        gps.stats(&chars, &sentences, &failed_checksum);
        if (debug) Serial.println("GPS turned off");
        digitalWrite(GPS_PIN, LOW); //GPS turned off
        pos = ConvertGPSdata(&coords, sizeof(gpscoord)); //Send data
        return pos;
      }
    }
  }
  pos = "No Signal";
}
void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 
   
  // Defined in thingProperties.h
  initProperties();
  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection, false);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(4);
  ArduinoCloud.printDebugInfo();
  pinMode(4 , OUTPUT);
  pinMode(backlights, OUTPUT);
  pinMode(pulsador, INPUT);
  pinMode(audio, OUTPUT);
  latitude  = 0.0f;
  longitude = 0.0f;
  altitud = 0;
  if (debug) {
    Serial.begin(9600);
    while (!Serial) {}// wait for serial port to connect. Needed for native USB port only
    Serial.println("Serial Connected");
  }
  //Serial1 pins 13-14 for 3.3V connection to GPS.
  Serial1.begin(9600);
  while (!Serial1) {}
  if (debug) {
    Serial.println("GPS Connected");
  }
  pinMode(GPS_PIN, OUTPUT); //pin de interruptor del GPS
  
}
void loop() {
  ArduinoCloud.update();
  // Your code here 
  String position_data;
  position_data = GetGPSpositon();
  //cloudLocation = {latitude, longitude};
  Serial.print("lat: ");
  Serial.print(latitude, 7);
  Serial.print("  Long: ");
  Serial.println(longitude, 7);
  String buf;
  buf = "";
  buf += F("Location, Lat: ");
  buf += latitude;
  buf += F(" Long: ");
  buf += longitude, 7;
  carrier_messenger = buf;
  Serial.println(carrier_messenger);
 ArduinoCloud.update();
 //delay(5000);
   Wait(WAITING_TIME, false);
}
/*
  Since Latitude is READ_WRITE variable, onLatitudeChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLatitudeChange()  {
  // Add your code here to act upon Latitude change
  ArduinoCloud.update();
}
/*
  Since Longitude is READ_WRITE variable, onLongitudeChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLongitudeChange()  {
  // Add your code here to act upon Longitude change
  ArduinoCloud.update();
}
/*
  Since Altitud is READ_WRITE variable, onAltitudChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onAltitudChange()  {
  // Add your code here to act upon Altitud change
  ArduinoCloud.update();
}
/*
  Since CarrierMessenger is READ_WRITE variable, 
onCarrierMessengerChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onCarrierMessengerChange()  {
  // Add your code here to act upon CarrierMessenger change
  ArduinoCloud.update();
}
/*
  Since Messenger is READ_WRITE variable, onMessengerChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onMessengerChange()  {
  // Add your code here to act upon Messenger change
  ArduinoCloud.update();
}

/*
  Since Longitud is READ_WRITE variable, onLongitudChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLongitudChange()  {
  // Add your code here to act upon Longitud change
  ArduinoCloud.update();
}